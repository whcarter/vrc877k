{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nmotor mDFL = motor(PORT11, ratio18_1, false);\n\nmotor mDFR = motor(PORT12, ratio18_1, true);\n\nmotor mDBL = motor(PORT13, ratio18_1, false);\n\nmotor mDBR = motor(PORT14, ratio18_1, true);\n\ngps holyBob = gps(PORT1, -88.90, -228.60, mm, 180);\ncontroller Controller1 = controller(primary);\nmotor mEND = motor(PORT16, ratio18_1, false);\n\nmotor Motor17 = motor(PORT17, ratio6_1, false);\n\nmotor mUPT = motor(PORT18, ratio6_1, false);\n\nmotor mFLY = motor(PORT19, ratio6_1, false);\n\nmotor mNDX = motor(PORT20, ratio36_1, true);\n\n/*vex-vision-config:begin*/\nvision::signature Vision1__BLUEHIGHGOAL = vision::signature (1, 6499, 8235, 7367,-2993, -1521, -2257,2.7, 0);\nvision::signature Vision1__REDHIGHGOAL = vision::signature (2, -5913, -3823, -4868,-5721, -3855, -4788,2.5, 0);\nvision Vision1 = vision (PORT10, 50, Vision1__BLUEHIGHGOAL, Vision1__REDHIGHGOAL);\n/*vex-vision-config:end*/\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       compTemplate3.0                                           */\n/*    Author:       Kayleen Smith, Team 877K                                  */\n/*    Created:      12/12/2022                                                */\n/*    Description:  Driver-Control Competition Template                       */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n// Include the V5 Library\n#include \"vex.h\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\ncompetition Competition = competition();\n\nbool porgUPT = false;  //A boolean variable (holds only the values of true or of false) that determines whether or not the intake system motor (mUPT) is on/at work\nbool porgFLY = false;   //A boolean variable that determines whether or not the flywheel motor (mFLY) is on/at work\nint intakeCooldown = 0; //An integer variable that implements a delay between button presses for the intake\nint flywheelCooldown = 0; //An integer variable that implements a delay between button presses for the flywheel\nint rollerCooldown = 0; //An integer variable that implements a delay between button presses for the roller\nbool onBlueAlliance = true;\nbool turningToGoal = false;\n\n//Turns the robot generally toward an angle measure\nvoid turnRobot(int degreesClockwise, int motorSpeed) {\n  //Rotations number is rounded if I combine the two variables, not sure why\n  double rotationsCoefficient = (19 / 2.75) / 360; //(drivetrain diameter / wheel diameter) / 360 degrees\n  double wheelRotations = abs(degreesClockwise) * rotationsCoefficient;\n  \n  mDFL.setVelocity(motorSpeed, percent);\n  mDFR.setVelocity(motorSpeed, percent);\n  mDBL.setVelocity(motorSpeed, percent);\n  mDBR.setVelocity(motorSpeed, percent);\n  mDFL.setPosition(0, degrees);\n\n  while (fabs(mDFL.position(degrees)) / 360 < wheelRotations) {\n    if (degreesClockwise > 0) {\n      mDFL.spin(forward);\n      mDFR.spin(reverse);\n      mDBL.spin(forward);\n      mDBR.spin(reverse);\n    } else {\n      mDFL.spin(reverse);\n      mDFR.spin(forward);\n      mDBL.spin(reverse);\n      mDBR.spin(forward);\n    }\n    \n    wait(100, msec);\n  }\n  mDFL.stop();\n  mDFR.stop();\n  mDBL.stop();\n  mDBR.stop();\n}\n\n//Makes turns by proportional control from motor rotation input\n//Pretty useless/imprecise, I made it by accident and it should probably never be used\nvoid Pturn(int degreesClockwise){\n  //Rotations number is rounded if I combine the two variables, not sure why\n  float rotationsCoefficient = (19 / 2.75) / 360; //(drivetrain diameter / wheel diameter) / 360 degrees\n  float wheelRotations = degreesClockwise * rotationsCoefficient;\n  mDFL.setPosition(0, degrees);\n  float Kp = 10;\n  float error = wheelRotations - mDFL.position(degrees) / 360;\n\n  while (error > 0) {\n    float error = wheelRotations - mDFL.position(degrees) / 360;\n    float motorPower = fabs(error) * Kp;\n\n    if (error > 0) {\n      mDFL.spin(forward, motorPower, volt);\n      mDFR.spin(reverse, motorPower, volt);\n      mDBL.spin(forward, motorPower, volt);\n      mDBR.spin(reverse, motorPower, volt);\n    } else {\n      mDFL.spin(reverse, motorPower, volt);\n      mDFR.spin(forward, motorPower, volt);\n      mDBL.spin(reverse, motorPower, volt);\n      mDBR.spin(forward, motorPower, volt);\n    }\n    printf(\"%f, %f, %f, %f\\n\",wheelRotations, mDFL.position(degrees) / 360, error, motorPower);\n    wait(100, msec);\n  }\n  mDFL.stop();\n  mDFR.stop();\n  mDBL.stop();\n  mDBR.stop();\n}\n\n//Uses Vision sensor input and PID control to turn towards a high goal\nvoid turnToGoal() {\n  int targetPosition = 158;\n  float Kp = 0.08;\n  float Ki = 0.001;\n  float Kd = 0.5;\n  float integral = 0;\n  float previous_error = 0;\n  float endTime = Brain.Timer.time(seconds) + 3;\n  turningToGoal = true;\n\n  while (true) {\n    Vision1.takeSnapshot(Vision1__BLUEHIGHGOAL);\n    if (Vision1.largestObject.exists) {\n      float error = targetPosition - Vision1.largestObject.centerX;\n      integral = integral + error;\n      if (fabs(error) < 1){\n        integral = 0;\n      }\n      if (fabs(error) > 200) {\n        integral = 0;\n      }\n      float derivative = error - previous_error;\n      previous_error = error;\n      float motorPower = Kp*error + Ki*integral + Kd*derivative;\n      if (motorPower > 0) {\n        mDFL.spin(reverse, fabs(motorPower), volt);\n        mDFR.spin(forward, fabs(motorPower), volt);\n        mDBL.spin(reverse, fabs(motorPower), volt);\n        mDBR.spin(forward, fabs(motorPower), volt);\n      } else if (motorPower < 0) {\n        mDFL.spin(forward, fabs(motorPower), volt);\n        mDFR.spin(reverse, fabs(motorPower), volt);\n        mDBL.spin(forward, fabs(motorPower), volt);\n        mDBR.spin(reverse, fabs(motorPower), volt);\n      }\n      if (Brain.Timer.time(seconds) >= endTime) {\n        mDFL.stop();\n        mDFR.stop();\n        mDBL.stop();\n        mDBR.stop();\n        turningToGoal = false;\n        break;\n      }\n    } else {\n      mDFL.stop();\n      mDFR.stop();\n      mDBL.stop();\n      mDBR.stop();\n    }\n    wait(10, msec);\n  }\n}\n\nvoid toggleFlywheel() {\n  if (flywheelCooldown == 0) {\n    porgFLY = !porgFLY;\n    flywheelCooldown = 3;\n  }\n}\n\nvoid toggleIntake() {\n  if (intakeCooldown == 0){\n    porgUPT = !porgUPT;\n    intakeCooldown = 3;\n  }\n}\n\nvoid spinRoller() {\n  if (rollerCooldown == 0) {\n    mUPT.spinFor(forward, 400, degrees, false);\n    Motor17.spinFor(forward, 600, degrees, false);\n    rollerCooldown = 7;\n  }\n}\n\n\n//Competition Functions\nvoid pre_auton() {\n\n}\n\nvoid autonomous() {\n\n  mDFL.setVelocity(50, percent);\n  mDFR.setVelocity(50, percent);\n  mDBL.setVelocity(50, percent);\n  mDBR.setVelocity(50, percent);\n\n  mDFL.spinFor(forward, 1, turns, false);\n  mDFR.spinFor(reverse, 1, turns, false);\n  mDBL.spinFor(reverse, 1, turns, false);\n  mDBR.spinFor(forward, 1, turns, true);\n\n  mDFR.spin(forward);\n  mDFL.spin(forward);\n  mDBR.spin(forward);\n  mDBL.spin(forward);\n\n  wait(500, msec);\n\n  mDFR.stop();\n  mDFL.stop();\n  mDBR.stop();\n  mDBL.stop();\n\n  mUPT.setVelocity(99, percent);\n  Motor17.setVelocity(99, percent);\n\n  mUPT.spinFor(reverse, 200, degrees, false);  //NOTE: last time this was tested was at 400, and that went way too far\n  Motor17.spinFor(reverse, 200, degrees, true);\n\n  wait(10000, msec);\n\n  /*if (true) {\n    mDFL.setVelocity(99, percent);\n    mDFR.setVelocity(99, percent);\n    mDBL.setVelocity(99, percent);\n    mDBR.setVelocity(99, percent);\n\n    mDFR.spin(reverse);\n    mDFL.spin(forward);\n    mDBR.spin(reverse);\n    mDBL.spin(forward);\n    mUPT.setVelocity(99, percent);              //set up intake and roller system\n    Motor17.setVelocity(99, percent);\n    mUPT.spin(forward);                         //spin intake and roller system\n    Motor17.spin(forward);\n  }*/\n}\n\nvoid drivercontrol() {\n  mNDX.setPosition(0, degrees);\n  mEND.setPosition(0, degrees);\n  while(true) {\n    mDFL.setVelocity((Controller1.Axis3.position(percent))+(Controller1.Axis4.position(percent))+(Controller1.Axis1.position(percent)), percent);\n    mDFR.setVelocity((Controller1.Axis3.position(percent))-(Controller1.Axis4.position(percent))-(Controller1.Axis1.position(percent)), percent);\n    mDBL.setVelocity((Controller1.Axis3.position(percent))-(Controller1.Axis4.position(percent))+(Controller1.Axis1.position(percent)), percent);\n    mDBR.setVelocity((Controller1.Axis3.position(percent))+(Controller1.Axis4.position(percent))-(Controller1.Axis1.position(percent)), percent);\n\n    mDFR.spin(forward);\n    mDFL.spin(forward);\n    mDBR.spin(forward);\n    mDBL.spin(forward);\n\n    mFLY.setVelocity(72, percent);              //setting up the flywheel: it will always be on, except for when the emergency stop button is pressed\n    \n    Controller1.ButtonL1.pressed(toggleFlywheel);\n    if(porgFLY) {\n      mFLY.spin(forward);\n    }\n    else {\n      mFLY.stop();\n    }\n    \n    mUPT.setVelocity(99, percent);              //setting up the intake system: it will be on after the intake button is pressed, and off before then\n    Motor17.setVelocity(99, percent);\n    Controller1.ButtonR1.pressed(toggleIntake);\n\n    Controller1.ButtonX.pressed(spinRoller);\n    if (rollerCooldown == 0){\n      if(porgUPT) {\n        mUPT.spin(forward);\n        Motor17.spin(forward);\n      }\n      else {\n        mUPT.stop();\n        Motor17.stop();\n      }\n    }\n    if(Controller1.ButtonDown.pressing()) {\n      mUPT.spin(reverse);\n      Motor17.spin(reverse);\n    }\n    \n\n    mNDX.setVelocity(99, percent);              //setting up the indexer: motor will be at rest except when button is pressed, where the indexer will quickly push a disc to the flywheel\n    if(Controller1.ButtonA.pressing()) {\n      mNDX.setTimeout(1, seconds);\n      mNDX.spinToPosition(55, degrees);\n      mNDX.spinToPosition(-5, degrees, false);\n    }\n    else {\n      mNDX.spinToPosition(-5, degrees, false);\n    }\n\n    /*\n    mEND.setVelocity(99, percent);               //setting up the endgame mechanism: it's at rest for the whole game, until button is pressed (w/in last 10 secs), where it'll unfurl the cord & gear attachment\n    if(Controller1.ButtonY.pressing()) {\n      mEND.spinFor(reverse, 180, degrees, true);\n      mEND.spin(forward);\n    }\n    if(Controller1.ButtonX.pressing()) {\n      mEND.stop();\n    }\n    if(Controller1.ButtonB.pressing()) {\n      mEND.spin(reverse);\n    }\n    */\n\n    Controller1.ButtonB.pressed(turnToGoal);\n    while (turningToGoal) {\n      wait(10, msec);\n    }\n\n\n    if (intakeCooldown > 0) {\n      intakeCooldown--;\n    }\n    if (flywheelCooldown > 0) {\n      flywheelCooldown--;\n    }\n    wait(2, msec);\n  }\n}\n\nint main() {\n  Competition.autonomous(autonomous);\n  Competition.drivercontrol(drivercontrol);\n  pre_auton();\n}\n\n","textLanguage":"cpp","rconfig":[{"port":[11],"name":"mDFL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[12],"name":"mDFR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[13],"name":"mDBL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[14],"name":"mDBR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[1],"name":"holyBob","customName":true,"deviceType":"GPS","deviceClass":"gps","setting":{"xOffset":"-88.9","xOffsetUnit":"mm","yOffset":"-228.6","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[16],"name":"mEND","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[17],"name":"Motor17","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[18],"name":"mUPT","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[19],"name":"mFLY","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[20],"name":"mNDX","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio36_1"},"triportSourcePort":22},{"port":[10],"name":"Vision1","customName":true,"deviceType":"Vision","deviceClass":"vision","setting":{"config":"{\"config\":{\"brightness\":50,\"signatures\":[{\"name\":\"BLUEHIGHGOAL\",\"parameters\":{\"uMin\":6499,\"uMax\":8235,\"uMean\":7367,\"vMin\":-2993,\"vMax\":-1521,\"vMean\":-2257,\"rgb\":6239785.468918602,\"type\":0,\"name\":\"BLUEHIGHGOAL\"},\"range\":2.7},{\"name\":\"REDHIGHGOAL\",\"parameters\":{\"uMin\":-5913,\"uMax\":-3823,\"uMean\":-4868,\"vMin\":-5721,\"vMax\":-3855,\"vMean\":-4788,\"rgb\":2637097.1489451476,\"type\":0,\"name\":\"REDHIGHGOAL\"},\"range\":2.5},{\"name\":\"SIG_3\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_3\"},\"range\":2.5},{\"name\":\"SIG_4\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_4\"},\"range\":2.5},{\"name\":\"SIG_5\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_5\"},\"range\":2.5},{\"name\":\"SIG_6\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_6\"},\"range\":2.5},{\"name\":\"SIG_7\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_7\"},\"range\":2.5}],\"codes\":[]}}","isConfigured":"false"},"triportSourcePort":22}],"slot":6,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.0","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}