{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START V5 MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END V5 MACROS\n\n\n// Robot configuration code.\nmotor mDFL = motor(PORT11, ratio18_1, false);\n\nmotor mDFR = motor(PORT12, ratio18_1, true);\n\nmotor mDBL = motor(PORT13, ratio18_1, false);\n\nmotor mDBR = motor(PORT14, ratio18_1, true);\n\ngps holyBob = gps(PORT1, -88.90, -228.60, mm, 180);\ncontroller Controller1 = controller(primary);\nmotor mEND = motor(PORT16, ratio18_1, false);\n\nmotor Motor17 = motor(PORT17, ratio6_1, false);\n\nmotor mUPT = motor(PORT18, ratio6_1, false);\n\nmotor mFLY = motor(PORT19, ratio6_1, false);\n\nmotor mNDX = motor(PORT20, ratio18_1, true);\n\n/*vex-vision-config:begin*/\nvision::signature Vision1__REDHIGHGOAL = vision::signature (1, 1639, 8391, 5015,-897, 341, -278,1, 0);\nvision::signature Vision1__BLUEHIGHGOAL = vision::signature (2, -2185, 1, -1092,713, 5003, 2858,1.3, 0);\nvision Vision1 = vision (PORT10, 50, Vision1__REDHIGHGOAL, Vision1__BLUEHIGHGOAL);\n/*vex-vision-config:end*/\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------------------------*/\n/*                                                                            */\n/*    Module:       compTemplate3.0                                           */\n/*    Author:       Kayleen Smith, Team 877K                                  */\n/*    Created:      12/12/2022                                                */\n/*    Description:  Driver-Control Competition Template                       */\n/*                                                                            */\n/*----------------------------------------------------------------------------*/\n\n// Include the V5 Library\n#include \"vex.h\"\n  \n// Allows for easier use of the VEX Library\nusing namespace vex;\n\ncompetition Competition = competition();\n\nbool porgUPT = false;  //A boolean variable (holds only the values of true or of false) that determines whether or not the intake system motor (mUPT) is on/at work\nbool porgFLY = false;   //A boolean variable that determines whether or not the flywheel motor (mFLY) is on/at work\nint intakeCooldown = 0; //An integer variable that implements a delay between button presses for the intake\nint flywheelCooldown = 0; //An integer variable that implements a delay between button presses for the flywheel\nint rollerCooldown = 0; //An integer variable that implements a delay between button presses for the roller\nbool onBlueAlliance = true;\n\n//Turns the robot generally toward an angle measure\nvoid turnRobot(int degreesClockwise, int motorSpeed) {\n  double wheelRotations = abs(degreesClockwise) * (16 * 3.14 * 1.41) / (2.5 * 360); //turn angle * (drivetrain diameter x pi x sqrt2) / (wheel diameter x 360 degrees)\n  if (degreesClockwise >= 0) {\n    mDBL.spinFor(forward, wheelRotations, turns);\n    mDBR.spinFor(forward, wheelRotations, turns);\n    mDFL.spinFor(forward, wheelRotations, turns);\n    mDFR.spinFor(forward, wheelRotations, turns);\n  } else {\n    mDBL.spinFor(reverse, wheelRotations, turns);\n    mDBR.spinFor(reverse, wheelRotations, turns);\n    mDFL.spinFor(reverse, wheelRotations, turns);\n    mDFR.spinFor(reverse, wheelRotations, turns);\n  }\n}\n\nvoid toggleFlywheel() {\n  if (flywheelCooldown == 0) {\n    porgFLY = !porgFLY;\n    flywheelCooldown = 3;\n  }\n}\n\nvoid toggleIntake() {\n  if (intakeCooldown == 0){\n    porgUPT = !porgUPT;\n    intakeCooldown = 3;\n  }\n}\n\nvoid spinRoller() {\n  if (rollerCooldown == 0) {\n    mUPT.spinFor(forward, 400, degrees, false);\n    Motor17.spinFor(forward, 600, degrees, false);\n    rollerCooldown = 7;\n  }\n}\n\n\nvoid alignToGoal() {\n  //Runs three times for accuracy\n  for (int i = 0; i < 3; i++) {\n    Vision1.takeSnapshot(Vision1__BLUEHIGHGOAL);\n    if (Vision1.largestObject.exists) {\n      int currentHeading = Vision1.largestObject.centerX + 0;\n      if(currentHeading > 160 || currentHeading < 140){\n        //turn right or left a little\n        turnRobot((150 - currentHeading) * (61/360), 40);\n      }\n    } else {\n      Vision1.takeSnapshot(Vision1__REDHIGHGOAL);\n      if (Vision1.largestObject.exists) {\n        int currentHeading = Vision1.largestObject.centerX + 0;\n        if(currentHeading > 160 || currentHeading < 140){\n          //turn right or left a little\n          turnRobot((150 - currentHeading) * (61/360), 40);\n        }\n      }\n    }\n  }\n}\n\n\n\n\nvoid pre_auton() {\n\n}\n\nvoid autonomous() {\n\n  mDFL.setVelocity(50, percent);\n  mDFR.setVelocity(50, percent);\n  mDBL.setVelocity(50, percent);\n  mDBR.setVelocity(50, percent);\n\n  mDFL.spinFor(forward, 1, turns, false);\n  mDFR.spinFor(reverse, 1, turns, false);\n  mDBL.spinFor(reverse, 1, turns, false);\n  mDBR.spinFor(forward, 1, turns, true);\n\n  mDFR.spin(forward);\n  mDFL.spin(forward);\n  mDBR.spin(forward);\n  mDBL.spin(forward);\n\n  wait(500, msec);\n\n  mDFR.stop();\n  mDFL.stop();\n  mDBR.stop();\n  mDBL.stop();\n\n  mUPT.setVelocity(99, percent);\n  Motor17.setVelocity(99, percent);\n\n  mUPT.spinFor(reverse, 200, degrees, false);  //NOTE: last time this was tested was at 400, and that went way too far\n  Motor17.spinFor(reverse, 200, degrees, true);\n\n  wait(10000, msec);\n\n  /*if (true) {\n    mDFL.setVelocity(99, percent);\n    mDFR.setVelocity(99, percent);\n    mDBL.setVelocity(99, percent);\n    mDBR.setVelocity(99, percent);\n\n    mDFR.spin(reverse);\n    mDFL.spin(forward);\n    mDBR.spin(reverse);\n    mDBL.spin(forward);\n    mUPT.setVelocity(99, percent);              //set up intake and roller system\n    Motor17.setVelocity(99, percent);\n    mUPT.spin(forward);                         //spin intake and roller system\n    Motor17.spin(forward);\n  }*/\n}\n\nvoid drivercontrol() {\n  mNDX.setPosition(0, degrees);\n  mEND.setPosition(0, degrees);\n  while(true) {\n    mDFL.setVelocity((Controller1.Axis3.position(percent))+(Controller1.Axis4.position(percent))+(Controller1.Axis1.position(percent)), percent);\n    mDFR.setVelocity((Controller1.Axis3.position(percent))-(Controller1.Axis4.position(percent))-(Controller1.Axis1.position(percent)), percent);\n    mDBL.setVelocity((Controller1.Axis3.position(percent))-(Controller1.Axis4.position(percent))+(Controller1.Axis1.position(percent)), percent);\n    mDBR.setVelocity((Controller1.Axis3.position(percent))+(Controller1.Axis4.position(percent))-(Controller1.Axis1.position(percent)), percent);\n\n    mDFR.spin(forward);\n    mDFL.spin(forward);\n    mDBR.spin(forward);\n    mDBL.spin(forward);\n\n    mFLY.setVelocity(72, percent);              //setting up the flywheel: it will always be on, except for when the emergency stop button is pressed\n    \n    Controller1.ButtonL1.pressed(toggleFlywheel);\n    if(porgFLY) {\n      mFLY.spin(forward);\n    }\n    else {\n      mFLY.stop();\n    }\n    \n    mUPT.setVelocity(99, percent);              //setting up the intake system: it will be on after the intake button is pressed, and off before then\n    Motor17.setVelocity(99, percent);\n    Controller1.ButtonR1.pressed(toggleIntake);\n\n    Controller1.ButtonX.pressed(spinRoller);\n    if (rollerCooldown == 0){\n      if(porgUPT) {\n        mUPT.spin(forward);\n        Motor17.spin(forward);\n      }\n      else {\n        mUPT.stop();\n        Motor17.stop();\n      }\n    }\n    if(Controller1.ButtonDown.pressing()) {\n      mUPT.spin(reverse);\n      Motor17.spin(reverse);\n    }\n    \n\n    mNDX.setVelocity(99, percent);              //setting up the indexer: motor will be at rest except when button is pressed, where the indexer will quickly push a disc to the flywheel\n    if(Controller1.ButtonA.pressing()) {\n      mNDX.spinToPosition(110, degrees);\n      mNDX.spinToPosition(-10, degrees, false);\n    }\n    else {\n      mNDX.spinToPosition(-10, degrees, false);\n    }\n\n    /*\n    mEND.setVelocity(99, percent);               //setting up the endgame mechanism: it's at rest for the whole game, until button is pressed (w/in last 10 secs), where it'll unfurl the cord & gear attachment\n    if(Controller1.ButtonY.pressing()) {\n      mEND.spinFor(reverse, 180, degrees, true);\n      mEND.spin(forward);\n    }\n    if(Controller1.ButtonX.pressing()) {\n      mEND.stop();\n    }\n    if(Controller1.ButtonB.pressing()) {\n      mEND.spin(reverse);\n    }\n    */\n\n    Controller1.ButtonB.pressed(alignToGoal);\n\n\n    if (intakeCooldown > 0) {\n      intakeCooldown--;\n    }\n    if (flywheelCooldown > 0) {\n      flywheelCooldown--;\n    }\n  }\n}\n\nint main() {\n  Competition.autonomous(autonomous);\n  Competition.drivercontrol(drivercontrol);\n  pre_auton();\n}\n\n","textLanguage":"cpp","rconfig":[{"port":[11],"name":"mDFL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[12],"name":"mDFR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[13],"name":"mDBL","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[14],"name":"mDBR","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[1],"name":"holyBob","customName":true,"deviceType":"GPS","deviceClass":"gps","setting":{"xOffset":"-88.9","xOffsetUnit":"mm","yOffset":"-228.6","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":22},{"port":[],"name":"Controller1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[16],"name":"mEND","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[17],"name":"Motor17","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[18],"name":"mUPT","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[19],"name":"mFLY","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[20],"name":"mNDX","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[10],"name":"Vision1","customName":true,"deviceType":"Vision","deviceClass":"vision","setting":{"config":"{\"config\":{\"brightness\":50,\"signatures\":[{\"name\":\"BLUEHIGHGOAL\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"BLUEHIGHGOAL\"},\"range\":2.5},{\"name\":\"REDHIGHGOAL\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"REDHIGHGOAL\"},\"range\":2.5},{\"name\":\"SIG_3\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_3\"},\"range\":2.5},{\"name\":\"SIG_4\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_4\"},\"range\":2.5},{\"name\":\"SIG_5\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_5\"},\"range\":2.5},{\"name\":\"SIG_6\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_6\"},\"range\":2.5},{\"name\":\"SIG_7\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_7\"},\"range\":2.5}],\"codes\":[]}}","isConfigured":"false"},"triportSourcePort":22}],"slot":4,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.0","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}